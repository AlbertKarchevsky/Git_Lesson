lol kek korvalol 

Лимоны желтые 
I love memes

Блаблабла

Лимоны желтые 
I love memes

Апельсины оранжевые 
Яблоки бывают и зелеными и красными 

Абд
лол кек 

Эта информация была добавлена из локального репозитория

Эта информация была добавлена в удаленном репозитории

Изменения

# Инструкция по работе с Git в VSCode

#### ( ...как будучи абсолютным чайником, пытаться сделать то, конечный результат чего, ты слабо себе представляешь, в программе и на языке, малоизвестных тебе, да еще в сжатые сроки? Или ***подсказки начинающим от начинающего***... :-)

## 1. Введение



Лучше чем на  [официальном сайте](https://git-scm.com/book/ru/v2/%D0%92%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%9E-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B5-%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D1%8F-%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D0%B9) производителя, о продукте не расскажут нигде.

****************************
## 2. Начало работы

Как ориентироваться в интерфейсе, что за чем следует, как глаза боятся, а руки делают?

+ создать папку, к примеру на рабочем столе, к примеру **lesson1**



+ запустить программу **VSCode**, посредницу между нами и **Git**, позволяющую с ним "общаться". Открыть созданную папку: **start** ---> **open**

+  в проводнике, в вышеуказанной папке, создать новый файл, к примеру **manual_git.md**  

( расширение **md** позволило  в наборе данной  инструкции использовать язык **Markdown**, для практики в его изучении )


+ необходимо получить возможность для ввода команд **Git**, для чего создать строку ввода - терминал: **панель задач** ---> **terminal** ---> **new terminal**


* перед началом использования **Git** удостовериться корректно ли он установлен и актуальна ли его версия. Использовать команду

> git --version




+ одно из правил **Git** требует не создавать репозиторий внутри репозитория, поэтому прежде чем наконец то перейти к использованию возможностей этой замечательной программы, необходимо проверить, а не является ли уже папка репозиторием?
Необходимо ввести команду
>git status

ответ на команду, начинающийся "fatal: not a git repository ..." должен внушить оптимизм, он говорит о том, что папка не является репозиторием и можно с полным правом сделать ее таковым. Необходимо ввести команду
> git init

теперь папка стала репозиторием

+ с созданием репозитория появляется возможность начать фиксировать изменения данных и действий с ними в папке-репозитории, т.е. делать **commit** 

( важно не забывать, что  прежде чем использовать команды **Git**, необходимо сохранять изменения в папке нажатием комбинации клавиш **CTRL+S** )

+ команда, которая должна всегда предшествовать фиксации состояния, т.е. созданию **commit** - это команда

> git add  manual_git.md

первая из рассматриваемых здесь команд **Git**, состоящая более чем из двух слов. Составная, где следом за  указанием действия **add** ( от англ. *add* - добавлять ) вводится наименование объекта, к которому действие направлено: к примеру файл **manual_git.md**. В терминале часть строки, следующая после **git add** именуется **зоной индексирования** или **staging area** 

можно заметить, что индекс **U** (
    от англ.  *untracked* - неотслеживаемый ), рядом с названием файла в проводнике, измениться на **A**, файл станет доступным к отслеживанию в **Git**

* теперь есть возможность в **измененном и добавленном в зону индексации** файле зафиксировать произошедшие изменения, т.е. сделать **commit**

> git commit -m "комментарий"

комментарий необходим, чтобы впоследствии логика внесенных в файл изменений, была понятна не только тому, кто их вносил, но и людям, которые будут работать с файлом, после или параллельно с создателем. 

*  Время создания **commit**, последнего и предшествующего ему, с указание автора ( его *email* ), будет доступно для просмотра после введения команды

> git log


********************************


* полезно запомнить, что:  
    -- при вводе **Git** команд, нажатием клавиши "стрелка вверх" клавиатуры автоматически будет введена одна из ранее использованных при работе команд;

    -- при вводе названия файла или **hach_of_commit**  ( уникального номера ),  достаточно ввести несколько символов, чтобы нажатием потом клавиши TAB активировать автодополнение названия

    -- нажатие клавиши Q не всегда возвращает в исходное состояние терминала и если такое случается, следует перезапустить терминал  **VSCode**

    -- команда **clear** позволяет очистить рабочее поле ввода в терминале  

+ в заключении первой части важные замечания от авторов **Git**

![](oficial_git.png)

**********************



## 3. Ветвление в Git. Конфликты при слиянии веток.

в продолжении 1 части настоящей инструкции, рассматривая предыдущий скриншот возможно наглядно представить 3 состояния файла в **Git**:

-- **modified** - измененный, но незафиксированный файл;

-- **staged** - измененный, индексированный ( отмеченный для включения в следующий **commit** ) файл;

-- **committed** - сохраненный в локальной базе файл, изменения которого зафиксированы 


+ команды, позволяющие увидеть изменения ( непосредственно добавленные и удаленные строки )  в файле, это

> git diff

она применяется для измененных, но еще не добавленных в зону индексации файлов

> git diff --cached ( или аналог git --staged )

для проиндексированных, но несохраненных файлов

+ следующая команда

> git checkout

позволяет переключаться на конкретный **commit**, если после ввода команды вводится **hash_of_commit** или на ветку, если указывается ее имя **branch name**

+ Особенность **Git**, отличающая его от других систем контроля версий, и создающая ему преимущества перед ними - это **легкий** ( занимающий небольшой объем памяти ), относительно других систем, **процесс ветвления** - возможность разделения первоначального проекта на ветви, параллельное развитие этих ветвей и возможность их слияния в последующем. **Git** позволяет избегая непоправимых ошибок в проекте, создавать различные его версии, используя в окончательной редакции объединенные результаты лучших из них. Стоит ли говорить, что командная работа в **Git** благодаря такому принципу его работы становится весьма эффективной. 

+ открывает список применяемых при ветвлении команд, естественно команда создания ветви

> git branch <branch_name>

( не лишним заметить, что при вводе <branch_name> - имени ветви, как собственно и при наименовании файлов, папок, для того, чтобы избежать некорректной работы **Git**, следует избегать употребления кириллицы и пробелов ) 

новичкам особенно внимательно **внимательно** нужно **проверять** **в** **какой** **ветви** ведется **работа**. Сделать это позволит команда 

> git branch

она выведет для просмотра список веток и активная ветвь будет выделена звездочкой  **\***

присвоить ветви **\*** , сделать ветвь активной позволит 

> git checkout <branch_name>

со временем, с получением опыта пользователю **Git** захочется ускориться в работе. Это возможно будет сделать применением команд более продвинутого уровня. Первая, рассматриваемая из подобных, команда из серии "два в одном"

> git checkout -b <branch_name>

она позволит сразу перейти в создаваемую папку, объединив создание и активацию папки в одном действии


независимо от того, в какой ветви проекта происходит работа,  вносимые изменения касаются всего проекта. Поэтому, перед созданием **commit**, при добавлении в область индексирования, указывается название не ветви, а именно проекта. В примере это файл manual_git.md и соответственно вводятся уже знакомые 


> git add manual_git.md

>git commit -m "комментарий о внесенных изменениях"



создав таким образом необходимое количество ветвей, рано или поздно приходиться столкнуться с необходимостью выбрать лучшие из них и соединить, целиком или частично в единый проект. В **Git**  такое соединение именуют слиянием, **merge** ( от англ. *merge* - поглощать, сливать )

>  git merge <branch_name>

( следует помнить, что слияние ветви <branch_name> происходит в ветвь, активную в данный момент )

чтобы не загромождать проект, ветви, информация из которых была использована при слиянии, удаляются после слияния командой 

> git --d <branch_name>

ветви, не используемые в проекте, не удачные варианты, удаляются командой

> git --D <branch_name>

дополнительную информацию о ветвлении дадут: команда для просмотра слитых ветвей

> git branch --merged

и команда просмотра ветвей, не объединенных

> git branch --no-merged


+ процесс **слияния** ветвей в **Git** - весьма **важная** часть в работе, всегда требующая особого внимания и понимания. Возникновение конфликтов при слиянии помогает отслеживать редактор слияния **Merge** **Editor**.
  
  Существует три варианта разрешения конфликтов

  -- **Accept Current Change** - использовать информацию из активной ветви  
-- **Accept Incoming Change** - использовать информацию из вливаемой ветви  
-- **Accept Both Change** - совместить варианты обеих ветвей 

***********************************

## 4. Работа с удаленным репозиторием. GitHub ##

полностью раскрыть все возможности и преимущества **Git** , в том, что касается групповой работы над проектом, а также практически полностью гарантировать сохранность данных, позволяет продукт Microsoft, удаленный репозиторий **GitHub**. Благодаря доступности и богатому функционалу он является в настоящее время самым популярным сервисом подобного плана



интерфейс **GitHab** интуитивно понятен и весьма удобен пользователю

создать свой репозиторий **new**, придать ему приватный или публичный характер, а так же настроить другие его параметры будет не сложно начинающему пользователю. Сложностью здесь может стать разве что знание, а чаще незнание английского.    
Выполнив предлагаемые настройки, в том числе создав **RIADME file**, т.е. сообщение, которое первым увидят зашедшие в создаваемый репозиторий люди,  останется зафиксировать свой выбор, кликнув **create repository**.   
Новый репозиторий создан и его адресом, уникальным идентификатором станет его URL - адрес в интернете

связать работу созданного на **Git Hub** репозитория с **Git** на своем компьютере позволяет команда

> git remot < name > < URL удаленного репозитория >

( где name - название удаленного репозитория )

name удаленного репозитория можно изменить командой

> git remot rename < name > < new name >  


поскольку удаленных репозиториев может быть несколько, отслеживать все возможно с помощью команды

> git remot 

а получить максимум информации об удаленном репозитории позволит команда


> git remot show

загружает данные из локального репозитория в удаленный команда

 

> git push < name > < branch_name >

( branch_name - имя ветки локального репозитория, которую необходимо "толкнуть" в удаленный )

**GitHab** позволяет осуществлять доступ к размещенному в нем удаленному репозиторию с нескольких устройств, что также способствует удобству в работе

вся  информация необходимая для продолжения работы над проектом с нового устройство клонируется 

> git clone < URL удаленного репозитория >

При этом название удаленного репозитория автоматически назначается **origin**. Для удобства и лучшего запоминания название можно поменять

обновлять состояние проекта до актуального, позволяют команды 

> git push

когда данные надо "толкать"  из локального репозитория в удаленный  и


> git pull

когда данные необходимо "тянуть" в локальный

пользуясь этими командами необходимо внимательно следить за тем, чтобы обновления происходили в одних и тех же ветвях удаленного и локального репозиториев, поскольку процесс обновления запускает попытки слияния, аналогичные **git merge** и при возникновении конфликтов разрешить ситуацию возможно отменой слияния 

> git merge --abort


**GitHub** позволяет реализовать множество разных возможностей и одним из интересных для современного программирования является возможность размещения так называемого открытого кода программы, когда к оригинальной идее разработчика имеют доступ другие программисты и принципы **GitHub** позволяют им предлагать в качестве развития идеи свои варианты  и дополнения. 
   
   Программистам предоставляется возможность получить доступ к репозиторию основного разработчика, иметь полную копию исходных данных. Идея это получила название **Fork**, вилка в переводе с английского.

   После внесения правок в исходный код разработчики могут предложить автору плоды своего труда, использую функцию **pull request**, с описанием внесенных изменений и условий возможного сотрудничества

   ************************
   &nbsp;
   ******



в заключении стоит сказать, что даже поверхностное знакомство с **Git** и **GitHub** вызывает **ощущение очень больших возможностей** этих программ и мотивирует к их более глубокому изучению

